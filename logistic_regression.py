# -*- coding: utf-8 -*-
"""Logistic_Regression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GROPgXm-O8Dln6_MUOrbSF2GYaDqqgPT
"""

import pandas as pd

# Load data
df = pd.read_csv('data.csv')

# Show first few rows
print(df.head())
print(df['diagnosis'].value_counts())

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# Drop non-feature columns, including the 'Unnamed: 32' column with NaNs
X = df.drop(['id', 'diagnosis', 'Unnamed: 32'], axis=1)
y = df['diagnosis'].map({'M': 1, 'B': 0})  # Malignant=1, Benign=0

# Split data
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=0, stratify=y
)

# Standardize features (important for logistic regression)
scaler = StandardScaler()
X_train_std = scaler.fit_transform(X_train)
X_test_std = scaler.transform(X_test)

from sklearn.linear_model import LogisticRegression

# Train model
clf = LogisticRegression(random_state=0)
clf.fit(X_train_std, y_train)

from sklearn.metrics import (
    confusion_matrix, precision_score, recall_score, roc_auc_score, roc_curve
)

# Predict probabilities and hard predictions
y_pred_proba = clf.predict_proba(X_test_std)[:, 1]
y_pred = (y_pred_proba >= 0.5).astype(int)  # default threshold: 0.5

# Metrics
cm = confusion_matrix(y_test, y_pred)
precision = precision_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)
roc_auc = roc_auc_score(y_test, y_pred_proba)

print("Confusion matrix:\n", cm)
print("Precision:", precision)
print("Recall:", recall)
print("ROC-AUC:", roc_auc)

import numpy as np

# Try a lower threshold (e.g., more sensitive test)
threshold = 0.3
y_pred_low_thresh = (y_pred_proba >= threshold).astype(int)

# New metrics
precision_low = precision_score(y_test, y_pred_low_thresh)
recall_low = recall_score(y_test, y_pred_low_thresh)
print(f'With threshold={threshold}:')
print("Precision:", precision_low)
print("Recall:", recall_low)

# Sigmoid illustration (plotting optional, but here's the formula)
def sigmoid(z):
    import numpy as np
    return 1 / (1 + np.exp(-z))

print(f"Sigmoid(0): {sigmoid(0)}")
print(f"Sigmoid(2): {sigmoid(2)}")
print(f"Sigmoid(-2): {sigmoid(-2)}")